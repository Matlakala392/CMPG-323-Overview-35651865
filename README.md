# CMPG-323-Overview-35651865
This repository contains the materials and documentation for my Project 1 in CMPG323.

(This Readme file is a copy of the original under project 1 class room, copied here for my personal 
convenience) 

## Repositories created and their corresponding projects are as follows:

Repository Name: CMPG-323-Overview-35651865,
Used for: Project 1.
Link: https://github.com/Matlakala392/CMPG-323-Overview-35651865

Repository Name: CMPG-323-Project-2,
Used for: Project 2.
https://github.com/NWU-CMPG323-2024/project-2-Matlakala392

Repository Name: CMPG-323-Project-3,
Used for: Project 3.
Link: https://github.com/NWU-CMPG323-2024/project-3-Matlakala392

Repository Name: CMPG-323-Project-4,
Used for: Project 4.
Link: https://github.com/NWU-CMPG323-2024/project-4-Matlakala392

Repository Name: CMPG-323-Project-5,
Used for: Project 5.
Link: https://github.com/NWU-CMPG323-2024/project-5-Matlakala392



## Link to Documentation Created:



## Branching Strategy to be Used in Each Project:

For each project, I will be working from the project's master branch, which represents the stable version of my code. This branch typically contains the code that is released or published. To maintain its stability, I will avoid adding new features directly to this branch.
To develop new features, I will create an isolated environment called the develop branch. This branch will serve as the working version of my code before it is merged into the master branch. From the develop branch, I will also create feature branches for specific tasks, such as the Tech Trends Solutions.
The workflow will be as follows:
1.	Create a feature branch from the develop branch.
2.	Work on the new feature in the feature branch.
3.	Once the feature is complete and tested, merge the feature branch back into the develop branch.
4.	After ensuring that the develop branch is stable and tested, merge it into the master branch.

This strategy ensures that new features are thoroughly tested in an isolated environment before being integrated into the stable version of the code. This branching strategy aligns with common practices in version control and software development.


## Explanation of What the .gitignore File Contains Within Each Project:

The `.gitignore` file is an essential tool for managing which files and directories should be ignored by Git. This is particularly useful for excluding files that are not necessary to track in your repository, such as build files, temporary files, sensitive information, or environment-specific files.

#### Usage in Development Frameworks

When working with development frameworks, like Visual Studio, numerous files are generated automatically that do not need to be tracked by version control. These files may include:

- **Build Artifacts:** Compiled binaries and libraries.
- **Temporary Files:** Files created by the IDE or during the build process.
- **Environment-Specific Files:** Configuration files specific to your development environment.
- **Dependency Directories:** Directories such as `node_modules` in a Node.js project or `bin` and `obj` directories in a .NET project.

By listing these files and directories in the `.gitignore` file, you ensure that they are not included in your Git commits, keeping your repository clean and focused on the source code and necessary configuration files.

#### Example for Visual Studio Projects

Here is an example of a `.gitignore` file for a Visual Studio project:

```plaintext
# Ignore Visual Studio temporary files, build results, and
# user-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# Avoid ignoring files in the .gitignore directory
!.gitignore

# Ignore build output directories
bin/
obj/
out/

# Ignore Visual Studio Code workspace and settings files
.vscode/

# Ignore NuGet packages
packages/

# Ignore environment variables
.env

# Ignore log files
*.log

# Ignore other system files
.DS_Store
Thumbs.db
```

This file lists common files and directories generated by Visual Studio that should not be tracked by Git, ensuring that your repository remains clean and free from unnecessary files.

By properly configuring the `.gitignore` file, you maintain a clean and efficient version control environment, focusing on the important aspects of your project while excluding irrelevant or unnecessary files.



## Explanation of the Storage of Credentials and Sensitive Information:

Properly managing the storage of credentials and sensitive information in GitHub projects is crucial for security. Here is a streamlined approach:

#### Use Environment Variables

Instead of hardcoding credentials in the code, use environment variables to store sensitive information such as API keys, passwords, and database credentials. This keeps sensitive details out of the source code.

#### Utilize the .gitignore File

Use the `.gitignore` file to exclude files containing sensitive information from being tracked by Git. For instance, store environment variables in a `.env` file and add it to `.gitignore`:

```plaintext
# .gitignore
.env
```

This prevents the `.env` file from being committed to the repository.

#### Employ Secrets Management

For secure storage of credentials, use GitHubâ€™s built-in secrets management. GitHub Actions provide a way to store and manage sensitive information securely. Secrets can be added in the repository settings and accessed in workflows without exposing the actual values in the code.

1. **Navigate to Repository Settings:**
   - Go to the GitHub repository.
   - Click on the **Settings** tab.

2. **Access Secrets:**
   - In the left sidebar, click on **Secrets and variables** under **Security**.
   - Click on **Actions**.

3. **Add New Secret:**
   - Click on **New repository secret**.
   - Enter a name and value for the secret (e.g., API keys, passwords).
   - Click **Add secret** to save it.

Access these secrets in workflows using `${{ secrets.SECRET_NAME }}`.

#### Avoid Hardcoding

Always avoid hardcoding sensitive information directly in the codebase. If sensitive information is accidentally committed, use tools like GitHub's "Remove sensitive data" feature to clean the commit history.

#### Conduct Regular Audits

Regularly audit repositories to ensure no sensitive information has been committed accidentally. Tools like GitGuardian can help detect and alert any exposed secrets. Regular audits help maintain a secure codebase and address potential security issues promptly.

By following these practices, credentials and sensitive information can be stored securely, minimizing the risk of unauthorized access and potential security breaches.
